// qwebpage.sip generated by MetaSIP
//
// This file is part of the QtWebKitWidgets Python extension module.
//
// Copyright (c) 2018 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt5.
// 
// This file may be used under the terms of the GNU General Public License
// version 3.0 as published by the Free Software Foundation and appearing in
// the file LICENSE included in the packaging of this file.  Please review the
// following information to ensure the GNU General Public License version 3.0
// requirements will be met: http://www.gnu.org/copyleft/gpl.html.
// 
// If you do not wish to use this file under the terms of the GPL version 3.0
// then you may purchase a commercial license.  For more information contact
// info@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


class QWebPage : QObject
{
%TypeHeaderCode
#include <qwebpage.h>
%End

public:
    enum NavigationType
    {
        NavigationTypeLinkClicked,
        NavigationTypeFormSubmitted,
        NavigationTypeBackOrForward,
        NavigationTypeReload,
        NavigationTypeFormResubmitted,
        NavigationTypeOther,
    };

    enum WebAction
    {
        NoWebAction,
        OpenLink,
        OpenLinkInNewWindow,
        OpenFrameInNewWindow,
        DownloadLinkToDisk,
        CopyLinkToClipboard,
        OpenImageInNewWindow,
        DownloadImageToDisk,
        CopyImageToClipboard,
        Back,
        Forward,
        Stop,
        Reload,
        Cut,
        Copy,
        Paste,
        Undo,
        Redo,
        MoveToNextChar,
        MoveToPreviousChar,
        MoveToNextWord,
        MoveToPreviousWord,
        MoveToNextLine,
        MoveToPreviousLine,
        MoveToStartOfLine,
        MoveToEndOfLine,
        MoveToStartOfBlock,
        MoveToEndOfBlock,
        MoveToStartOfDocument,
        MoveToEndOfDocument,
        SelectNextChar,
        SelectPreviousChar,
        SelectNextWord,
        SelectPreviousWord,
        SelectNextLine,
        SelectPreviousLine,
        SelectStartOfLine,
        SelectEndOfLine,
        SelectStartOfBlock,
        SelectEndOfBlock,
        SelectStartOfDocument,
        SelectEndOfDocument,
        DeleteStartOfWord,
        DeleteEndOfWord,
        SetTextDirectionDefault,
        SetTextDirectionLeftToRight,
        SetTextDirectionRightToLeft,
        ToggleBold,
        ToggleItalic,
        ToggleUnderline,
        InspectElement,
        InsertParagraphSeparator,
        InsertLineSeparator,
        SelectAll,
        ReloadAndBypassCache,
        PasteAndMatchStyle,
        RemoveFormat,
        ToggleStrikethrough,
        ToggleSubscript,
        ToggleSuperscript,
        InsertUnorderedList,
        InsertOrderedList,
        Indent,
        Outdent,
        AlignCenter,
        AlignJustified,
        AlignLeft,
        AlignRight,
        StopScheduledPageRefresh,
        CopyImageUrlToClipboard,
        OpenLinkInThisWindow,
%If (Qt_5_2_0 -)
        DownloadMediaToDisk,
%End
%If (Qt_5_2_0 -)
        CopyMediaUrlToClipboard,
%End
%If (Qt_5_2_0 -)
        ToggleMediaControls,
%End
%If (Qt_5_2_0 -)
        ToggleMediaLoop,
%End
%If (Qt_5_2_0 -)
        ToggleMediaPlayPause,
%End
%If (Qt_5_2_0 -)
        ToggleMediaMute,
%End
%If (Qt_5_2_0 -)
        ToggleVideoFullscreen,
%End
    };

    enum FindFlag
    {
        FindBackward,
        FindCaseSensitively,
        FindWrapsAroundDocument,
        HighlightAllOccurrences,
%If (Qt_5_2_0 -)
        FindAtWordBeginningsOnly,
%End
%If (Qt_5_2_0 -)
        TreatMedialCapitalAsWordBeginning,
%End
%If (Qt_5_2_0 -)
        FindBeginsInSelection,
%End
    };

    typedef QFlags<QWebPage::FindFlag> FindFlags;

    enum LinkDelegationPolicy
    {
        DontDelegateLinks,
        DelegateExternalLinks,
        DelegateAllLinks,
    };

    enum WebWindowType
    {
        WebBrowserWindow,
        WebModalDialog,
    };

    explicit QWebPage(QObject *parent /TransferThis/ = 0);
    virtual ~QWebPage();
    QWebFrame *mainFrame() const;
    QWebFrame *currentFrame() const;
    QWebHistory *history() const;
    QWebSettings *settings() const;
    void setView(QWidget *view /KeepReference/);
    QWidget *view() const;
    bool isModified() const;
    QUndoStack *undoStack() const;
    void setNetworkAccessManager(QNetworkAccessManager *manager /KeepReference/);
    QNetworkAccessManager *networkAccessManager() const;
    void setPluginFactory(QWebPluginFactory *factory /KeepReference/);
    QWebPluginFactory *pluginFactory() const;
    quint64 totalBytes() const;
    quint64 bytesReceived() const;
    QString selectedText() const;
    QAction *action(QWebPage::WebAction action) const;
    virtual void triggerAction(QWebPage::WebAction action, bool checked = false);
    QSize viewportSize() const;
    void setViewportSize(const QSize &size) const;
    virtual bool event(QEvent *);
    bool focusNextPrevChild(bool next);
    QVariant inputMethodQuery(Qt::InputMethodQuery property) const;
    bool findText(const QString &subString, QFlags<QWebPage::FindFlag> options = 0);
    void setForwardUnsupportedContent(bool forward);
    bool forwardUnsupportedContent() const;
    void setLinkDelegationPolicy(QWebPage::LinkDelegationPolicy policy);
    QWebPage::LinkDelegationPolicy linkDelegationPolicy() const;
    void setPalette(const QPalette &palette);
    QPalette palette() const;
    bool swallowContextMenuEvent(QContextMenuEvent *event);
    void updatePositionDependentActions(const QPoint &pos);

    enum Extension
    {
        ChooseMultipleFilesExtension,
        ErrorPageExtension,
    };

    class ExtensionOption
    {
%TypeHeaderCode
#include <qwebpage.h>
%End
    };

    class ExtensionReturn
    {
%TypeHeaderCode
#include <qwebpage.h>
%End
    };

    virtual bool extension(QWebPage::Extension extension, const QWebPage::ExtensionOption *option = 0, QWebPage::ExtensionReturn *output = 0);
%VirtualCatcherCode
        const sipTypeDef *option_type = sipType_QWebPage_ExtensionOption;
        const sipTypeDef *return_type = sipType_QWebPage_ExtensionReturn;
        
        if (a0 == QWebPage::ChooseMultipleFilesExtension)
        {
            option_type = sipType_QWebPage_ChooseMultipleFilesExtensionOption;
            return_type = sipType_QWebPage_ChooseMultipleFilesExtensionReturn;
        }
        else if (a0 == QWebPage::ErrorPageExtension)
        {
            option_type = sipType_QWebPage_ErrorPageExtensionOption;
            return_type = sipType_QWebPage_ErrorPageExtensionReturn;
        }
        
        PyObject *res_obj = sipCallMethod(&sipIsErr, sipMethod, "FDD",
                a0, sipType_QWebPage_Extension,
                a1, option_type, NULL,
                a2, return_type, NULL);
        
        if (res_obj)
        {
            sipParseResult(&sipIsErr, sipMethod, res_obj, "b", &sipRes);
            Py_DECREF(res_obj);
        }
        else
        {
            sipIsErr = 1;
        }
%End

    virtual bool supportsExtension(QWebPage::Extension extension) const;

signals:
    void loadFinished(bool ok);
    void loadProgress(int progress);
    void loadStarted();
    void linkHovered(const QString &link, const QString &title, const QString &textContent);
    void statusBarMessage(const QString &text);
    void selectionChanged();
    void frameCreated(QWebFrame *frame);
    void geometryChangeRequested(const QRect &geom);
    void repaintRequested(const QRect &dirtyRect);
    void scrollRequested(int dx, int dy, const QRect &scrollViewRect);
    void windowCloseRequested();
    void printRequested(QWebFrame *frame);
    void linkClicked(const QUrl &url);
    void toolBarVisibilityChangeRequested(bool visible);
    void statusBarVisibilityChangeRequested(bool visible);
    void menuBarVisibilityChangeRequested(bool visible);
    void unsupportedContent(QNetworkReply *reply);
    void downloadRequested(const QNetworkRequest &request);
    void microFocusChanged();

protected:
    virtual QWebPage *createWindow(QWebPage::WebWindowType type);
    virtual QObject *createPlugin(const QString &classid, const QUrl &url, const QStringList &paramNames, const QStringList &paramValues);
    virtual bool acceptNavigationRequest(QWebFrame *frame, const QNetworkRequest &request, QWebPage::NavigationType type);
    virtual QString chooseFile(QWebFrame *originatingFrame, const QString &oldFile);
    virtual void javaScriptAlert(QWebFrame *originatingFrame, const QString &msg);
    virtual bool javaScriptConfirm(QWebFrame *originatingFrame, const QString &msg);
    virtual bool javaScriptPrompt(QWebFrame *originatingFrame, const QString &msg, const QString &defaultValue, QString *result /Out/);
    virtual void javaScriptConsoleMessage(const QString &message, int lineNumber, const QString &sourceID);
    virtual QString userAgentForUrl(const QUrl &url) const;

public:
    void setContentEditable(bool editable);
    bool isContentEditable() const;
    QMenu *createStandardContextMenu() /Factory/;

    class ChooseMultipleFilesExtensionOption : QWebPage::ExtensionOption
    {
%TypeHeaderCode
#include <qwebpage.h>
%End

    public:
        QWebFrame *parentFrame;
        QStringList suggestedFileNames;
    };

    class ChooseMultipleFilesExtensionReturn : QWebPage::ExtensionReturn
    {
%TypeHeaderCode
#include <qwebpage.h>
%End

    public:
        QStringList fileNames;
    };

signals:
    void contentsChanged();
    void databaseQuotaExceeded(QWebFrame *frame, QString databaseName);
    void saveFrameStateRequested(QWebFrame *frame, QWebHistoryItem *item);
    void restoreFrameStateRequested(QWebFrame *frame);

public:
    QWebFrame *frameAt(const QPoint &pos) const;
    QSize preferredContentsSize() const;
    void setPreferredContentsSize(const QSize &size) const;

    enum ErrorDomain
    {
        QtNetwork,
        Http,
        WebKit,
    };

    class ErrorPageExtensionOption : QWebPage::ExtensionOption
    {
%TypeHeaderCode
#include <qwebpage.h>
%End

    public:
        QUrl url;
        QWebFrame *frame;
        QWebPage::ErrorDomain domain;
        int error;
        QString errorString;
    };

    class ErrorPageExtensionReturn : QWebPage::ExtensionReturn
    {
%TypeHeaderCode
#include <qwebpage.h>
%End

    public:
        ErrorPageExtensionReturn();
        QString contentType;
        QString encoding;
        QUrl baseUrl;
        QByteArray content;
    };

    virtual bool shouldInterruptJavaScript();

    enum PermissionPolicy
    {
        PermissionUnknown,
        PermissionGrantedByUser,
        PermissionDeniedByUser,
    };

    enum Feature
    {
        Notifications,
        Geolocation,
    };

    class ViewportAttributes
    {
%TypeHeaderCode
#include <qwebpage.h>
%End

    public:
        ViewportAttributes();
        ViewportAttributes(const QWebPage::ViewportAttributes &other);
        ~ViewportAttributes();
        qreal initialScaleFactor() const;
        qreal minimumScaleFactor() const;
        qreal maximumScaleFactor() const;
        qreal devicePixelRatio() const;
        bool isUserScalable() const;
        bool isValid() const;
        QSizeF size() const;
    };

    bool hasSelection() const;
    QString selectedHtml() const;
    QWebPage::ViewportAttributes viewportAttributesForSize(const QSize &availableSize) const;
    void setActualVisibleContentRect(const QRect &rect) const;
    void setFeaturePermission(QWebFrame *frame, QWebPage::Feature feature, QWebPage::PermissionPolicy policy);
    QStringList supportedContentTypes() const;
    bool supportsContentType(const QString &mimeType) const;

signals:
    void applicationCacheQuotaExceeded(QWebSecurityOrigin *origin, quint64 defaultOriginQuota, quint64 totalSpaceNeeded);
    void viewportChangeRequested();
    void featurePermissionRequested(QWebFrame *frame, QWebPage::Feature feature);
    void featurePermissionRequestCanceled(QWebFrame *frame, QWebPage::Feature feature);

public:
%If (Qt_5_2_0 -)

    enum VisibilityState
    {
        VisibilityStateVisible,
        VisibilityStateHidden,
        VisibilityStatePrerender,
        VisibilityStateUnloaded,
    };

%End
%If (Qt_5_2_0 -)
    QWebPage::VisibilityState visibilityState() const;
%End
%If (Qt_5_2_0 -)
    void setVisibilityState(QWebPage::VisibilityState);
%End
};

QFlags<QWebPage::FindFlag> operator|(QWebPage::FindFlag f1, QFlags<QWebPage::FindFlag> f2);
