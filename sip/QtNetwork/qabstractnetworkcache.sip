// qabstractnetworkcache.sip generated by MetaSIP on Sat Oct  5 02:32:30 2013
//
// This file is part of the QtNetwork Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt5.
// 
// This file may be used under the terms of the GNU General Public License
// version 3.0 as published by the Free Software Foundation and appearing in
// the file LICENSE included in the packaging of this file.  Please review the
// following information to ensure the GNU General Public License version 3.0
// requirements will be met: http://www.gnu.org/copyleft/gpl.html.
// 
// If you do not wish to use this file under the terms of the GPL version 3.0
// then you may purchase a commercial license.  For more information contact
// info@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%ModuleCode
#include <qabstractnetworkcache.h>
%End

// QHash<QNetworkRequest::Attribute, QVariant> is implemented as a Python dict.
%MappedType QHash<QNetworkRequest::Attribute, QVariant> /DocType="dict-of-QNetworkRequest.Attribute-object"/
{
%TypeHeaderCode
#include <qhash.h>
#include <qnetworkrequest.h>
#include <qvariant.h>
%End

%ConvertFromTypeCode
    // Create the dictionary.
    PyObject *d = PyDict_New();

    if (!d)
        return NULL;

    // Set the dictionary elements.
    QHash<QNetworkRequest::Attribute, QVariant>::const_iterator i = sipCpp->constBegin();

    while (i != sipCpp->constEnd())
    {
        PyObject *t1obj = sipConvertFromEnum((int)i.key(),
                sipType_QNetworkRequest_Attribute);

        QVariant *t2 = new QVariant(i.value());
        PyObject *t2obj = sipConvertFromNewType(t2, sipType_QVariant,
                sipTransferObj);

        if (!t1obj || !t2obj || PyDict_SetItem(d, t1obj, t2obj) < 0)
        {
            Py_DECREF(d);
            Py_XDECREF(t1obj);

            if (t2obj)
            {
                Py_DECREF(t2obj);
            }
            else
            {
                delete t2;
            }

            return 0;
        }

        Py_DECREF(t1obj);
        Py_DECREF(t2obj);

        ++i;
    }

    return d;
%End

%ConvertToTypeCode
    PyObject *t1obj, *t2obj;
    SIP_SSIZE_T i = 0;

    // Check the type if that is all that is required.
    if (!sipIsErr)
    {
        if (!PyDict_Check(sipPy))
            return 0;

        while (PyDict_Next(sipPy, &i, &t1obj, &t2obj))
        {
            if (!sipCanConvertToEnum(t1obj, sipType_QNetworkRequest_Attribute))
                return 0;

            if (!sipCanConvertToType(t2obj, sipType_QVariant, SIP_NOT_NONE))
                return 0;
        } 

        return 1;
    }

    QHash<QNetworkRequest::Attribute, QVariant> *qm = new QHash<QNetworkRequest::Attribute, QVariant>;
 
    while (PyDict_Next(sipPy, &i, &t1obj, &t2obj))
    {
        PyErr_Clear();
        QNetworkRequest::Attribute t1 = (QNetworkRequest::Attribute)SIPLong_AsLong(t1obj);

        if (PyErr_Occurred())
            *sipIsErr = 1;

        int state2;
        QVariant *t2 = reinterpret_cast<QVariant *>(sipConvertToType(t2obj,
                sipType_QVariant, sipTransferObj, SIP_NOT_NONE, &state2,
                sipIsErr));

        if (*sipIsErr)
        {
            delete qm;
            return 0;
        }

        qm->insert(t1, *t2);
 
        sipReleaseType(t2, sipType_QVariant, state2);
    }
 
    *sipCppPtr = qm;
 
    return sipGetState(sipTransferObj);
%End
};

class QNetworkCacheMetaData
{
%TypeHeaderCode
#include <qabstractnetworkcache.h>
%End

    typedef QList<QPair<QByteArray, QByteArray>> RawHeaderList;
    typedef QHash<QNetworkRequest::Attribute, QVariant> AttributesMap;

public:
    QNetworkCacheMetaData();
    QNetworkCacheMetaData(const QNetworkCacheMetaData &other);
    ~QNetworkCacheMetaData();
    bool operator==(const QNetworkCacheMetaData &other) const;
    bool operator!=(const QNetworkCacheMetaData &other) const;
    bool isValid() const;
    QUrl url() const;
    void setUrl(const QUrl &url);
    RawHeaderList rawHeaders() const;
    void setRawHeaders(const RawHeaderList &headers);
    QDateTime lastModified() const;
    void setLastModified(const QDateTime &dateTime);
    QDateTime expirationDate() const;
    void setExpirationDate(const QDateTime &dateTime);
    bool saveToDisk() const;
    void setSaveToDisk(bool allow);
    AttributesMap attributes() const;
    void setAttributes(const AttributesMap &attributes);
    void swap(QNetworkCacheMetaData &other);
};

QDataStream &operator<<(QDataStream &, const QNetworkCacheMetaData & /Constrained/) /ReleaseGIL/;
QDataStream &operator>>(QDataStream &, QNetworkCacheMetaData & /Constrained/) /ReleaseGIL/;

class QAbstractNetworkCache : QObject
{
%TypeHeaderCode
#include <qabstractnetworkcache.h>
%End

public:
    virtual ~QAbstractNetworkCache();
    virtual QNetworkCacheMetaData metaData(const QUrl &url) = 0;
    virtual void updateMetaData(const QNetworkCacheMetaData &metaData) = 0;
    virtual QIODevice *data(const QUrl &url) = 0 /Factory/;
    virtual bool remove(const QUrl &url) = 0;
    virtual qint64 cacheSize() const = 0;
    virtual QIODevice *prepare(const QNetworkCacheMetaData &metaData) = 0;
    virtual void insert(QIODevice *device) = 0;

public slots:
    virtual void clear() = 0;

protected:
    explicit QAbstractNetworkCache(QObject *parent /TransferThis/ = 0);

private:
    QAbstractNetworkCache(const QAbstractNetworkCache &);
};
